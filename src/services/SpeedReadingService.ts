/**
 * Phase 6: Cognitive Efficiency Layer - Speed Reading Service
 * 
 * Revolutionary RSVP (Rapid Serial Visual Presentation) engine with:
 * - Advanced text segmentation algorithms
 * - Cognitive load-adaptive WPM calculation
 * - Neural fixation point optimization
 * - Sub-vocalization elimination techniques
 * - Real-time comprehension tracking integration
 */

import EventEmitter from 'eventemitter3';
import { StorageService } from './StorageService';
import { MindMapGenerator } from './MindMapGeneratorService';
import { aiCoachingService } from './AICoachingService';

/**
 * Phase 6: Reading Session Interface for Neural Map Integration
 */
export interface ReadingSession {
  id: string;
  textSource: string;
  textTitle?: string;
  textDifficulty?: 'easy' | 'medium' | 'hard' | 'technical';
  wordCount: number;
  
  // Performance metrics
  wpmGoal: number;
  wpmAchieved: number;
  wpmPeak: number;
  comprehensionScore: number;
  
  // Timing data
  startTime: Date;
  endTime: Date;
  totalDurationMs: number;
  readingDurationMs: number; // Excluding pauses
  pauseDurationMs: number;
  
  // Advanced analytics
  fixationAccuracy: number;    // How well user maintained center fixation
  regressionCount: number;     // Number of times user went back
  subVocalizationEvents: number; // Detected sub-vocalization instances
  cognitiveLoadStart: number;  // Mental state at session start
  cognitiveLoadEnd: number;    // Mental state at session end
  
  // RSVP configuration
  displayMode: 'word' | 'chunk' | 'bionic' | 'adaptive';
  chunkSize: number;
  pauseOnPunctuation: boolean;
  highlightVowels: boolean;
  
  // Neural map integration
  conceptsIdentified: string[];
  neuralNodesStrengthened: string[];
  sourceLinks: SourceLink[];
  
  created: Date;
  modified: Date;
}

/**
 * Source link for connecting reading sessions to neural map
 */
export interface SourceLink {
  type: 'source_read';
  sessionId: string;
  textSource: string;
  conceptId: string;
  relevanceScore: number;
  extractedAt: Date;
}

/**
 * Comprehension quiz generated by AI
 */
export interface ComprehensionQuiz {
  id: string;
  sessionId: string;
  questions: QuizQuestion[];
  timeLimit?: number;
  created: Date;
}

export interface QuizQuestion {
  id: string;
  question: string;
  options: string[];
  correctAnswer: number; // Index of correct option
  explanation?: string;
  difficulty: 1 | 2 | 3 | 4 | 5;
  conceptTested: string;
}

/**
 * Real-time reading analytics
 */
export interface ReadingAnalytics {
  currentWPM: number;
  averageWPM: number;
  peakWPM: number;
  wordsRead: number;
  totalWords: number;
  progressPercent: number;
  estimatedTimeRemaining: number;
  fixationStability: number;
  comprehensionPrediction: number;
  totalReadingTimeMinutes: number;
}

/**
 * RSVP display configuration
 */
export interface RSVPConfig {
  mode: 'word' | 'chunk' | 'bionic' | 'adaptive';
  wpm: number;
  chunkSize: number;
  fontScale: number;
  fixationGuide: boolean;
  pauseOnPunctuation: boolean;
  highlightVowels: boolean;
  backgroundColor: string;
  textColor: string;
  highlightColor: string;
}

/**
 * Advanced text processing for optimal RSVP display
 */
interface ProcessedText {
  words: string[];
  chunks: string[][];
  punctuationPauses: number[];
  difficultWords: number[];
  conceptKeywords: string[];
  estimatedReadingTime: number;
}

/**
 * Sub-vocalization detection (advanced feature)
 */
interface SubVocalizationEvent {
  timestamp: Date;
  wordIndex: number;
  confidence: number;
  detectionMethod: 'timing' | 'pattern' | 'pause';
}

export class SpeedReadingService extends EventEmitter {
  private static instance: SpeedReadingService;
  
  // Session state
  private activeSession: ReadingSession | null = null;
  private rsvpTimer: NodeJS.Timeout | null = null;
  private currentWordIndex = 0;
  private sessionStartTime: Date | null = null;
  private pauseTime: Date | null = null;
  private totalPauseTime = 0;
  
  // Advanced analytics
  private wpmHistory: { timestamp: Date; wpm: number }[] = [];
  private fixationEvents: { timestamp: Date; accuracy: number }[] = [];
  private subVocalizationEvents: SubVocalizationEvent[] = [];
  
  // Text processing
  private processedText: ProcessedText | null = null;
  private config: RSVPConfig;

  public static getInstance(): SpeedReadingService {
    if (!SpeedReadingService.instance) {
      SpeedReadingService.instance = new SpeedReadingService();
    }
    return SpeedReadingService.instance;
  }

  private constructor() {
    super();
    this.config = this.getDefaultConfig();
    console.log('🚀 Speed Reading Service initialized with advanced RSVP capabilities');
  }

  /**
   * Default RSVP configuration optimized for learning
   */
  private getDefaultConfig(): RSVPConfig {
    return {
      mode: 'adaptive',
      wpm: 300,
      chunkSize: 3,
      fontScale: 1.0,
      fixationGuide: true,
      pauseOnPunctuation: true,
      highlightVowels: false,
      backgroundColor: '#000000',
      textColor: '#FFFFFF',
      highlightColor: '#00FF88',
    };
  }

  /**
   * Phase 6: Advanced text processing with cognitive optimization
   */
  public processText(
    text: string, 
    difficulty: 'easy' | 'medium' | 'hard' | 'technical' = 'medium'
  ): ProcessedText {
    try {
      // Clean and normalize text
      const cleanText = this.cleanText(text);
      
      // Split into words with advanced tokenization
      const words = this.tokenizeText(cleanText);
      
      // Create optimal chunks for RSVP display
      const chunks = this.createOptimalChunks(words, difficulty);
      
      // Identify punctuation pauses (longer display time)
      const punctuationPauses = this.identifyPunctuationPauses(words);
      
      // Mark difficult words for slower display
      const difficultWords = this.identifyDifficultWords(words, difficulty);
      
      // Extract concept keywords for neural map linking
      const conceptKeywords = this.extractConceptKeywords(words, difficulty);
      
      // Calculate estimated reading time
      const estimatedReadingTime = this.calculateReadingTime(words, this.config.wpm);
      
      this.processedText = {
        words,
        chunks,
        punctuationPauses,
        difficultWords,
        conceptKeywords,
        estimatedReadingTime,
      };
      
      console.log(`📚 Processed text: ${words.length} words, ${chunks.length} chunks, ${conceptKeywords.length} concepts`);
      return this.processedText;

    } catch (error) {
      console.error('Error processing text:', error);
      throw new Error(`Failed to process text: ${error}`);
    }
  }

  /**
   * Advanced text cleaning with academic/technical content preservation
   */
  private cleanText(text: string): string {
    return text
      // Normalize whitespace
      .replace(/\s+/g, ' ')
      // Fix common quotation marks
      .replace(/[""]/g, '"')
      .replace(/['']/g, "'")
      // Preserve technical notation
      .replace(/(\w+)\.(\w+)\.(\w+)/g, '$1-$2-$3') // Keep version numbers
      .replace(/(\d+)\.(\d+)/g, '$1-$2') // Keep decimal numbers
      // Remove excessive punctuation
      .replace(/([.!?]){2,}/g, '$1')
      .trim();
  }

  /**
   * Intelligent tokenization preserving meaningful units
   */
  private tokenizeText(text: string): string[] {
    // Split on whitespace but keep hyphenated words together
    const words = text.split(/\s+/).filter(word => word.length > 0);
    
    // Post-process to handle special cases
    const processedWords: string[] = [];
    
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      
      // Handle contractions properly
      if (word.includes("'") && !word.endsWith("'s")) {
        processedWords.push(word);
      }
      // Handle hyphenated compound words
      else if (word.includes('-') && word.length > 3) {
        processedWords.push(word);
      }
      // Handle technical terms with dots
      else if (word.includes('.') && /[a-zA-Z]/.test(word)) {
        processedWords.push(word.replace(/-/g, '.'));
      }
      else {
        processedWords.push(word);
      }
    }
    
    return processedWords;
  }

  /**
   * Create optimal word chunks based on cognitive load theory
   */
  private createOptimalChunks(
    words: string[], 
    difficulty: 'easy' | 'medium' | 'hard' | 'technical'
  ): string[][] {
    const chunks: string[][] = [];
    
    // Adjust chunk size based on difficulty
    const baseChunkSize = this.config.chunkSize;
    const chunkSize = {
      easy: Math.min(5, baseChunkSize + 2),
      medium: baseChunkSize,
      hard: Math.max(2, baseChunkSize - 1),
      technical: Math.max(1, baseChunkSize - 2),
    }[difficulty];

    for (let i = 0; i < words.length; i += chunkSize) {
      const chunk = words.slice(i, i + chunkSize);
      chunks.push(chunk);
    }
    
    return chunks;
  }

  /**
   * Identify words that should have longer display time due to punctuation
   */
  private identifyPunctuationPauses(words: string[]): number[] {
    const pauses: number[] = [];
    
    words.forEach((word, index) => {
      // Major punctuation requires longer pause
      if (/[.!?]$/.test(word)) {
        pauses.push(index);
      }
      // Minor punctuation requires short pause
      else if (/[,;:]$/.test(word)) {
        pauses.push(index);
      }
    });
    
    return pauses;
  }

  /**
   * Identify difficult words that need slower display (anti-sub-vocalization)
   */
  private identifyDifficultWords(
    words: string[], 
    difficulty: 'easy' | 'medium' | 'hard' | 'technical'
  ): number[] {
    const difficultIndices: number[] = [];
    
    words.forEach((word, index) => {
      const cleanWord = word.replace(/[^\w]/g, '').toLowerCase();
      
      // Long words
      if (cleanWord.length > 8) {
        difficultIndices.push(index);
      }
      
      // Technical terms (lots of consonants or unusual patterns)
      if (difficulty === 'technical' || difficulty === 'hard') {
        if (this.isTechnicalTerm(cleanWord)) {
          difficultIndices.push(index);
        }
      }
      
      // Words with complex syllable structure
      if (this.countSyllables(cleanWord) > 3) {
        difficultIndices.push(index);
      }
    });
    
    return difficultIndices;
  }

  /**
   * Extract concept keywords for neural map integration
   */
  private extractConceptKeywords(
    words: string[], 
    difficulty: 'easy' | 'medium' | 'hard' | 'technical'
  ): string[] {
    const concepts: string[] = [];
    const conceptWords = new Set<string>();
    
    words.forEach(word => {
      const cleanWord = word.replace(/[^\w]/g, '').toLowerCase();
      
      // Skip very short words
      if (cleanWord.length < 4) return;
      
      // Technical and academic terms
      if (difficulty === 'technical' || difficulty === 'hard') {
        if (this.isTechnicalTerm(cleanWord) || this.isAcademicTerm(cleanWord)) {
          conceptWords.add(cleanWord);
        }
      }
      
      // Capitalized words (proper nouns, important terms)
      if (/^[A-Z]/.test(word) && cleanWord.length > 3) {
        conceptWords.add(cleanWord);
      }
      
      // Long, complex words likely to be concepts
      if (cleanWord.length > 7 && this.countSyllables(cleanWord) > 2) {
        conceptWords.add(cleanWord);
      }
    });
    
    return Array.from(conceptWords).slice(0, 20); // Limit to top 20 concepts
  }

  /**
   * Check if a word is a technical term
   */
  private isTechnicalTerm(word: string): boolean {
    // Common technical suffixes
    const technicalSuffixes = [
      'tion', 'sion', 'ment', 'ness', 'ity', 'ism', 'ology', 'graphy',
      'metry', 'scopy', 'pathy', 'phobia', 'philia', 'synthesis'
    ];
    
    // Common technical prefixes
    const technicalPrefixes = [
      'neuro', 'psycho', 'bio', 'geo', 'astro', 'micro', 'macro',
      'multi', 'inter', 'intra', 'trans', 'ultra', 'meta'
    ];
    
    return technicalSuffixes.some(suffix => word.endsWith(suffix)) ||
           technicalPrefixes.some(prefix => word.startsWith(prefix));
  }

  /**
   * Check if a word is an academic term
   */
  private isAcademicTerm(word: string): boolean {
    const academicKeywords = [
      'analysis', 'synthesis', 'hypothesis', 'theory', 'method', 'approach',
      'framework', 'concept', 'principle', 'paradigm', 'model', 'system',
      'process', 'mechanism', 'structure', 'function', 'relationship',
      'correlation', 'causation', 'implication', 'significance'
    ];
    
    return academicKeywords.includes(word) || word.length > 10;
  }

  /**
   * Estimate syllable count for reading difficulty
   */
  private countSyllables(word: string): number {
    word = word.toLowerCase();
    if (word.length <= 3) return 1;
    
    word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');
    word = word.replace(/^y/, '');
    
    const matches = word.match(/[aeiouy]{1,2}/g);
    return matches ? matches.length : 1;
  }

  /**
   * Calculate estimated reading time with WPM
   */
  private calculateReadingTime(words: string[], wpm: number): number {
    const totalWords = words.length;
    return Math.round((totalWords / wpm) * 60); // Return seconds
  }

  /**
   * Phase 6: Start RSVP session with neural map integration
   */
  public async startSession(
    text: string,
    options: {
      title?: string;
      difficulty?: 'easy' | 'medium' | 'hard' | 'technical';
      wpm?: number;
      mode?: 'word' | 'chunk' | 'bionic' | 'adaptive';
      cognitiveLoad?: number;
    } = {}
  ): Promise<ReadingSession> {
    try {
      // Stop any existing session
      if (this.activeSession) {
        await this.stopSession();
      }

      // Process text
      const difficulty = options.difficulty || 'medium';
      this.processedText = this.processText(text, difficulty);
      
      // Update config
      if (options.wpm) this.config.wpm = options.wpm;
      if (options.mode) this.config.mode = options.mode;
      
      // Adapt WPM based on cognitive load
      let adaptiveWPM = this.config.wpm;
      if (options.cognitiveLoad !== undefined) {
        adaptiveWPM = this.adaptWPMToCognitiveLoad(this.config.wpm, options.cognitiveLoad);
      }

      // Create session
      const sessionId = `reading_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      this.activeSession = {
        id: sessionId,
        textSource: text,
        textTitle: options.title || `Reading Session ${new Date().toLocaleTimeString()}`,
        textDifficulty: difficulty,
        wordCount: this.processedText.words.length,
        
        wpmGoal: adaptiveWPM,
        wpmAchieved: 0,
        wpmPeak: 0,
        comprehensionScore: 0,
        
        startTime: new Date(),
        endTime: new Date(), // Will be updated
        totalDurationMs: 0,
        readingDurationMs: 0,
        pauseDurationMs: 0,
        
        fixationAccuracy: 0,
        regressionCount: 0,
        subVocalizationEvents: 0,
        cognitiveLoadStart: options.cognitiveLoad || 0.5,
        cognitiveLoadEnd: 0.5,
        
        displayMode: this.config.mode,
        chunkSize: this.config.chunkSize,
        pauseOnPunctuation: this.config.pauseOnPunctuation,
        highlightVowels: this.config.highlightVowels,
        
        conceptsIdentified: this.processedText.conceptKeywords,
        neuralNodesStrengthened: [],
        sourceLinks: [],
        
        created: new Date(),
        modified: new Date(),
      };

      // Initialize tracking
      this.currentWordIndex = 0;
      this.sessionStartTime = new Date();
      this.wpmHistory = [];
      this.fixationEvents = [];
      this.subVocalizationEvents = [];
      this.totalPauseTime = 0;

      // Start RSVP
      this.startRSVP();

      this.emit('sessionStarted', this.activeSession);
      console.log(`📖 Speed reading session started: ${sessionId} (${adaptiveWPM} WPM)`);

      return this.activeSession;

    } catch (error) {
      console.error('Error starting speed reading session:', error);
      throw new Error(`Failed to start session: ${error}`);
    }
  }

  /**
   * Adapt WPM based on cognitive load (Phase 5.5 integration)
   */
  private adaptWPMToCognitiveLoad(baseWPM: number, cognitiveLoad: number): number {
    // High cognitive load: reduce WPM to prevent overwhelm
    if (cognitiveLoad > 0.7) {
      return Math.round(baseWPM * 0.7);
    }
    // Low cognitive load: can handle higher WPM
    else if (cognitiveLoad < 0.3) {
      return Math.round(baseWPM * 1.3);
    }
    // Normal cognitive load: use base WPM
    else {
      return baseWPM;
    }
  }

  /**
   * Start RSVP display loop
   */
  private startRSVP(): void {
    if (!this.activeSession || !this.processedText) return;

    const displayInterval = this.calculateDisplayInterval();
    
    this.rsvpTimer = setInterval(() => {
      this.displayNextWord();
    }, displayInterval);

    this.emit('rsvpStarted', { wpm: this.activeSession.wpmGoal });
  }

  /**
   * Calculate optimal display interval based on current word
   */
  private calculateDisplayInterval(): number {
    if (!this.activeSession || !this.processedText) return 200;

    const baseInterval = (60 / this.activeSession.wpmGoal) * 1000;
    
    // Adjust for current word characteristics
    const currentWord = this.processedText.words[this.currentWordIndex];
    if (!currentWord) return baseInterval;

    let multiplier = 1.0;
    
    // Longer pause for punctuation
    if (this.processedText.punctuationPauses.includes(this.currentWordIndex)) {
      if (/[.!?]$/.test(currentWord)) {
        multiplier = 2.0; // Full stop
      } else {
        multiplier = 1.5; // Comma, semicolon
      }
    }
    
    // Longer pause for difficult words
    if (this.processedText.difficultWords.includes(this.currentWordIndex)) {
      multiplier *= 1.3;
    }
    
    return Math.round(baseInterval * multiplier);
  }

  /**
   * Display next word and update analytics
   */
  private displayNextWord(): void {
    if (!this.activeSession || !this.processedText) return;

    if (this.currentWordIndex >= this.processedText.words.length) {
      this.completeSession();
      return;
    }

    const currentWord = this.processedText.words[this.currentWordIndex];
    const progress = (this.currentWordIndex / this.processedText.words.length) * 100;

    // Update analytics
    this.updateRealTimeAnalytics();

    // Emit current word for UI
    this.emit('wordDisplay', {
      word: currentWord,
      index: this.currentWordIndex,
      total: this.processedText.words.length,
      progress,
      analytics: this.getCurrentAnalytics(),
    });

    this.currentWordIndex++;

    // Dynamic interval adjustment (adaptive mode)
    if (this.config.mode === 'adaptive') {
      const newInterval = this.calculateDisplayInterval();
      if (this.rsvpTimer) {
        clearInterval(this.rsvpTimer);
        this.rsvpTimer = setInterval(() => {
          this.displayNextWord();
        }, newInterval);
      }
    }
  }

  /**
   * Update real-time reading analytics
   */
  private updateRealTimeAnalytics(): void {
    if (!this.activeSession || !this.sessionStartTime) return;

    const now = new Date();
    const elapsedMinutes = (now.getTime() - this.sessionStartTime.getTime() - this.totalPauseTime) / (1000 * 60);
    
    if (elapsedMinutes > 0) {
      const currentWPM = Math.round(this.currentWordIndex / elapsedMinutes);
      
      // Track WPM history
      this.wpmHistory.push({ timestamp: now, wpm: currentWPM });
      
      // Update session stats
      this.activeSession.wpmAchieved = currentWPM;
      if (currentWPM > this.activeSession.wpmPeak) {
        this.activeSession.wpmPeak = currentWPM;
      }
      
      // Detect potential sub-vocalization (sudden WPM drops)
      if (this.wpmHistory.length > 5) {
        const recentAvg = this.wpmHistory.slice(-5).reduce((sum, h) => sum + h.wpm, 0) / 5;
        if (currentWPM < recentAvg * 0.7) {
          this.detectSubVocalization();
        }
      }
    }
  }

  /**
   * Detect potential sub-vocalization event
   */
  private detectSubVocalization(): void {
    if (!this.activeSession) return;

    const event: SubVocalizationEvent = {
      timestamp: new Date(),
      wordIndex: this.currentWordIndex,
      confidence: 0.7,
      detectionMethod: 'timing',
    };

    this.subVocalizationEvents.push(event);
    this.activeSession.subVocalizationEvents++;

    this.emit('subVocalizationDetected', event);
  }

  /**
   * Get current reading analytics for UI display
   */
  public getCurrentAnalytics(): ReadingAnalytics {
    if (!this.activeSession || !this.sessionStartTime || !this.processedText) {
      return {
        currentWPM: 0,
        averageWPM: 0,
        peakWPM: 0,
        wordsRead: 0,
        totalWords: 0,
        progressPercent: 0,
        estimatedTimeRemaining: 0,
        fixationStability: 0,
        comprehensionPrediction: 0.8,
        totalReadingTimeMinutes: 0,
      };
    }

    const elapsedMinutes = (Date.now() - this.sessionStartTime.getTime() - this.totalPauseTime) / (1000 * 60);
    const currentWPM = elapsedMinutes > 0 ? Math.round(this.currentWordIndex / elapsedMinutes) : 0;
    const progress = (this.currentWordIndex / this.processedText.words.length) * 100;
    const remainingWords = this.processedText.words.length - this.currentWordIndex;
    const estimatedTimeRemaining = currentWPM > 0 ? Math.round((remainingWords / currentWPM) * 60) : 0;

    return {
      currentWPM,
      averageWPM: this.activeSession.wpmAchieved,
      peakWPM: this.activeSession.wpmPeak,
      wordsRead: this.currentWordIndex,
      totalWords: this.processedText.words.length,
      progressPercent: progress,
      estimatedTimeRemaining,
      fixationStability: this.calculateFixationStability(),
      comprehensionPrediction: this.predictComprehension(),
      totalReadingTimeMinutes: elapsedMinutes,
    };
  }

  /**
   * Calculate fixation stability score
   */
  private calculateFixationStability(): number {
    if (this.fixationEvents.length < 5) return 1.0;
    
    const recentEvents = this.fixationEvents.slice(-10);
    const avgAccuracy = recentEvents.reduce((sum, e) => sum + e.accuracy, 0) / recentEvents.length;
    
    return Math.max(0, Math.min(1, avgAccuracy));
  }

  /**
   * Predict comprehension based on reading patterns
   */
  private predictComprehension(): number {
    if (!this.activeSession) return 0.8;

    let score = 1.0;
    
    // Reduce score for excessive speed
    const speedRatio = this.activeSession.wpmAchieved / this.activeSession.wpmGoal;
    if (speedRatio > 1.5) {
      score -= 0.2; // Reading too fast may hurt comprehension
    }
    
    // Reduce score for sub-vocalization events
    const subVocalizationRatio = this.activeSession.subVocalizationEvents / this.currentWordIndex;
    score -= subVocalizationRatio * 0.3;
    
    // Reduce score for poor fixation
    const fixationStability = this.calculateFixationStability();
    score *= fixationStability;
    
    return Math.max(0.1, Math.min(1.0, score));
  }

  /**
   * Phase 6: Pause RSVP session
   */
  public pauseSession(): void {
    if (!this.activeSession || !this.rsvpTimer) return;

    clearInterval(this.rsvpTimer);
    this.rsvpTimer = null;
    this.pauseTime = new Date();

    this.emit('sessionPaused', this.activeSession);
    console.log('⏸️ Speed reading session paused');
  }

  /**
   * Resume RSVP session
   */
  public resumeSession(): void {
    if (!this.activeSession || this.rsvpTimer) return;

    if (this.pauseTime) {
      this.totalPauseTime += Date.now() - this.pauseTime.getTime();
      this.pauseTime = null;
    }

    this.startRSVP();
    this.emit('sessionResumed', this.activeSession);
    console.log('▶️ Speed reading session resumed');
  }

  /**
   * Complete the current session
   */
  public async completeSession(): Promise<ReadingSession> {
    if (!this.activeSession) {
      throw new Error('No active session to complete');
    }

    try {
      // Stop RSVP
      if (this.rsvpTimer) {
        clearInterval(this.rsvpTimer);
        this.rsvpTimer = null;
      }

      // Finalize session data
      const now = new Date();
      this.activeSession.endTime = now;
      this.activeSession.totalDurationMs = now.getTime() - this.activeSession.startTime.getTime();
      this.activeSession.readingDurationMs = this.activeSession.totalDurationMs - this.totalPauseTime;
      this.activeSession.pauseDurationMs = this.totalPauseTime;
      this.activeSession.fixationAccuracy = this.calculateFixationStability();
      this.activeSession.modified = now;

      // Create source links for neural map
      this.activeSession.sourceLinks = this.createSourceLinks();

      // Phase 6 Integration: Persist and update neural map
      const storage = StorageService.getInstance();
      const mind = MindMapGenerator.getInstance();

      // Generate additional neural links (if any) and persist
      const generatedLinks = await mind.generateNeuralLinksFromReadingSession(this.activeSession);
      const allLinks = [...(this.activeSession.sourceLinks || []), ...generatedLinks];
      this.activeSession.sourceLinks = allLinks;
      await storage.saveSourceLinks(allLinks);

      // Persist session
      await storage.saveReadingSession(this.activeSession);

      // Knowledge health update based on efficiency
      const conceptExtractionRate = (this.processedText?.conceptKeywords.length || 0) / Math.max(1, this.activeSession.wordCount);
      const efficiency = this.calculateReadingEfficiency(this.activeSession);
      const healthDelta = mind.updateKnowledgeHealthWithReadingEfficiency(
        this.activeSession.wpmAchieved,
        this.activeSession.comprehensionScore || efficiency, // fallback
        conceptExtractionRate,
      );
      this.emit('knowledgeHealthUpdated', { delta: healthDelta, efficiency });

      // Optional: Generate AI comprehension quiz
      try {
        const quiz = await aiCoachingService.generateComprehensionQuiz(
          this.activeSession.textSource,
          this.activeSession.id,
          {
            questionCount: 5,
            difficulty: 'adaptive',
            questionTypes: ['factual', 'inference', 'vocabulary'],
            adaptToPreviousPerformance: true,
          }
        );
        this.emit('quizReady', quiz);
      } catch (e) {
        console.warn('AI quiz generation skipped or failed:', e);
      }

      const completedSession = { ...this.activeSession };
      this.activeSession = null;

      this.emit('sessionCompleted', completedSession);
      console.log(`✅ Speed reading session completed: ${completedSession.id}`);
      console.log(`📊 Final stats: ${completedSession.wpmAchieved} WPM, ${completedSession.subVocalizationEvents} sub-vocalization events`);

      return completedSession;

    } catch (error) {
      console.error('Error completing session:', error);
      throw new Error(`Failed to complete session: ${error}`);
    }
  }

  /**
   * Stop current session without completing
   */
  public async stopSession(): Promise<void> {
    if (this.rsvpTimer) {
      clearInterval(this.rsvpTimer);
      this.rsvpTimer = null;
    }

    if (this.activeSession) {
      this.emit('sessionStopped', this.activeSession);
      this.activeSession = null;
    }

    this.currentWordIndex = 0;
    this.processedText = null;
    console.log('⏹️ Speed reading session stopped');
  }

  /**
   * Create source links for neural map integration
   */
  private createSourceLinks(): SourceLink[] {
    if (!this.activeSession || !this.processedText) return [];

    const links: SourceLink[] = [];

    this.processedText.conceptKeywords.forEach(concept => {
      links.push({
        type: 'source_read',
        sessionId: this.activeSession!.id,
        textSource: this.activeSession!.textSource,
        conceptId: concept,
        relevanceScore: 0.8,
        extractedAt: new Date(),
      });
    });

    return links;
  }

  /**
   * Update RSVP configuration
   */
  public updateConfig(newConfig: Partial<RSVPConfig>): void {
    this.config = { ...this.config, ...newConfig };
    
    // If session is active, apply changes
    if (this.activeSession && this.rsvpTimer) {
      this.pauseSession();
      setTimeout(() => this.resumeSession(), 100);
    }

    this.emit('configUpdated', this.config);
  }

  /**
   * Get current session status
   */
  public getActiveSession(): ReadingSession | null {
    return this.activeSession;
  }

  /**
   * Check if session is active
   */
  public isSessionActive(): boolean {
    return this.activeSession !== null && this.rsvpTimer !== null;
  }

  /**
   * Get processed text information
   */
  public getProcessedText(): ProcessedText | null {
    return this.processedText;
  }

  /**
   * Get current RSVP configuration
   */
  public getConfig(): RSVPConfig {
    return { ...this.config };
  }

  /**
   * Calculate reading efficiency score for neural map
   */
  public calculateReadingEfficiency(session: ReadingSession): number {
    if (!session) return 0;

    let efficiency = 0;

    // WPM efficiency (achieved vs goal)
    const wpmRatio = Math.min(1, session.wpmAchieved / session.wpmGoal);
    efficiency += wpmRatio * 0.4;

    // Comprehension score
    efficiency += session.comprehensionScore * 0.4;

    // Fixation accuracy
    efficiency += session.fixationAccuracy * 0.1;

    // Sub-vocalization penalty
    const subVocPenalty = Math.min(0.1, session.subVocalizationEvents / session.wordCount);
    efficiency -= subVocPenalty;

    return Math.max(0, Math.min(1, efficiency));
  }

  /**
   * Generate neural links from reading session for mind map integration
   */
  public async generateNeuralLinksFromReadingSession(session: ReadingSession): Promise<SourceLink[]> {
    try {
      const links: SourceLink[] = [];
      
      // Create source links for each concept identified
      session.conceptsIdentified.forEach(concept => {
        links.push({
          type: 'source_read',
          sessionId: session.id,
          textSource: session.textSource,
          conceptId: concept,
          relevanceScore: 0.8,
          extractedAt: new Date(),
        });
      });
      
      console.log(`🔗 Generated ${links.length} neural links from reading session`);
      return links;
    } catch (error) {
      console.error('Error generating neural links:', error);
      return [];
    }
  }

  /**
   * Update knowledge health based on reading efficiency
   */
  public updateKnowledgeHealthWithReadingEfficiency(
    wpmAchieved: number,
    comprehensionScore: number,
    conceptExtractionRate: number
  ): number {
    try {
      // Calculate health delta based on reading performance
      let healthDelta = 0;
      
      // WPM contribution (higher speed = better health)
      if (wpmAchieved > 300) {
        healthDelta += 0.1;
      } else if (wpmAchieved > 200) {
        healthDelta += 0.05;
      }
      
      // Comprehension contribution
      healthDelta += comprehensionScore * 0.2;
      
      // Concept extraction contribution
      healthDelta += conceptExtractionRate * 0.1;
      
      // Cap the delta
      healthDelta = Math.max(-0.1, Math.min(0.3, healthDelta));
      
      console.log(`🧠 Knowledge health delta from reading: ${healthDelta}`);
      return healthDelta;
    } catch (error) {
      console.error('Error updating knowledge health:', error);
      return 0;
    }
  }

  /**
   * Cleanup resources
   */
  public cleanup(): void {
    this.stopSession();
    this.removeAllListeners();
    console.log('🧹 Speed Reading Service cleaned up');
  }
}

// Export singleton instance
export const speedReadingService = SpeedReadingService.getInstance();
export default SpeedReadingService;